# День 27: flutter_bloc (BLoC/Cubit) - Конспект

## Содержание
1. [Зачем нужен BLoC](#зачем-нужен-bloc)
2. [Cubit - простой вход в BLoC](#cubit---простой-вход-в-bloc)
3. [BlocProvider, BlocBuilder, BlocListener](#blocprovider-blocbuilder-bloclistener)
4. [Паттерн состояний: loading/success/error](#паттерн-состояний-loadingsuccesserror)
5. [Чек-листы использования](#чек-листы-использования)
6. [Вопросы для самопроверки](#вопросы-для-самопроверки)

---

## Зачем нужен BLoC

### Что это такое
BLoC (Business Logic Component) - это паттерн управления состоянием, который разделяет бизнес-логику от UI. Основная идея: **события преобразуются в состояния**. UI отправляет события, BLoC обрабатывает их и возвращает новое состояние, UI реагирует на изменение состояния.

**Основные преимущества:**
- **Предсказуемость**: четкий поток данных (UI → События → Логика → Состояния → UI)
- **Тестируемость**: бизнес-логику можно тестировать независимо от UI
- **Переиспользуемость**: одна логика может использоваться в разных частях приложения
- **Разделение ответственности**: UI занимается только отображением, логика - только обработкой данных

### Когда применять
- Сложная бизнес-логика с множеством состояний
- Необходимость переиспользования логики в разных экранах
- Приложения требующие высокой тестируемости
- Работа с асинхронными операциями (API, БД)
- Команды разработчиков (единый стиль архитектуры)

### Типичные ошибки и подводные камни
1. **Излишнее использование**: Не нужно создавать BLoC для простых локальных состояний (например, открыта ли выпадающая панель). Используйте StatefulWidget для таких случаев.
2. **Мутация состояния**: Никогда не изменяйте существующее состояние напрямую. Всегда создавайте новый объект состояния через `copyWith()` или создание нового экземпляра.

---

## Cubit - простой вход в BLoC

### Что это такое
Cubit - это упрощённая версия BLoC без явных событий. Вместо событий используются прямые методы. Это более простой и интуитивный подход для начинающих.

**Структура Cubit:**
```dart
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0);  // начальное состояние

  void increment() => emit(state + 1);  // изменение состояния
  void decrement() => emit(state - 1);
}
```

**Отличия от BLoC:**
- Cubit: методы вызываются напрямую (проще, меньше кода)
- BLoC: события обрабатываются через обработчики (более структурировано для сложной логики)

### Когда применять
- Простая логика с несколькими действиями
- Прототипирование и быстрая разработка
- Обучение паттерну управления состоянием
- Когда не нужна детальная история событий

### Типичные ошибки и подводные камни
1. **Забывание про async/await**: При асинхронных операциях не забывайте про `async` и `await`, иначе состояние может измениться раньше времени.
2. **Слишком много логики в методах**: Если методы Cubit становятся большими и сложными, возможно стоит перейти на полноценный BLoC с событиями.

---

## BlocProvider, BlocBuilder, BlocListener

### Что это такое

**BlocProvider** - виджет, который предоставляет экземпляр BLoC/Cubit дереву виджетов ниже. Использует InheritedWidget под капотом.
```dart
BlocProvider(
  create: (context) => CounterCubit(),
  child: MyScreen(),
)
```

**BlocBuilder** - виджет, который перестраивает UI при изменении состояния.
```dart
BlocBuilder<CounterCubit, int>(
  builder: (context, state) {
    return Text('$state');
  },
)
```

**BlocListener** - виджет для выполнения побочных эффектов (навигация, показ диалогов, SnackBar) при изменении состояния. НЕ перестраивает UI.
```dart
BlocListener<LoginBloc, LoginState>(
  listener: (context, state) {
    if (state.status == LoginStatus.success) {
      Navigator.push(...);
    }
  },
  child: LoginForm(),
)
```

**BlocSelector** - оптимизация BlocBuilder, перестраивается только при изменении выбранной части состояния.
```dart
BlocSelector<UserBloc, UserState, String>(
  selector: (state) => state.name,  // слушаем только name
  builder: (context, name) {
    return Text(name);
  },
)
```

### Когда применять
- **BlocProvider**: В корне экрана или приложения для предоставления BLoC
- **BlocBuilder**: Когда нужно перестроить UI на основе состояния
- **BlocListener**: Для навигации, показа диалогов, отображения SnackBar
- **BlocSelector**: Для оптимизации - когда нужна только часть состояния

### Типичные ошибки и подводные камни
1. **Создание BLoC внутри build**: Никогда не создавайте новый экземпляр BLoC внутри `build()` метода - это приведёт к утечкам памяти и потере состояния.
2. **Игнорирование buildWhen/listenWhen**: Без условий перестройки виджет будет обновляться на каждое изменение состояния, даже если это не нужно. Используйте `buildWhen` и `listenWhen` для оптимизации.
   ```dart
   BlocBuilder<UserBloc, UserState>(
     buildWhen: (previous, current) => previous.name != current.name,
     builder: (context, state) => Text(state.name),
   )
   ```

---

## Паттерн состояний: loading/success/error

### Что это такое
Это стандартный паттерн для работы с асинхронными операциями. Любая операция загрузки данных проходит через эти состояния:
- **loading** - данные загружаются, показываем индикатор
- **success** - данные загружены успешно, показываем результат
- **error** - произошла ошибка, показываем сообщение об ошибке

**Реализация:**
```dart
enum DataStatus { initial, loading, success, error }

class DataState {
  final DataStatus status;
  final List<String>? data;
  final String? error;

  const DataState({
    required this.status,
    this.data,
    this.error,
  });
}
```

### Когда применять
- Запросы к API
- Загрузка данных из базы данных
- Любые асинхронные операции с несколькими исходами
- Формы с отправкой на сервер

### Типичные ошибки и подводные камни
1. **Забывание состояния initial**: Многие забывают про начальное состояние и начинают сразу с loading, что может привести к неожиданному поведению UI.
2. **Хранение старых данных при ошибке**: При ошибке иногда полезно сохранять предыдущие данные, чтобы пользователь не терял контекст. Подумайте, нужно ли очищать данные при ошибке.
   ```dart
   // Плохо: теряем данные
   emit(state.copyWith(status: Status.error, data: null, error: e.toString()));

   // Хорошо: сохраняем данные
   emit(state.copyWith(status: Status.error, error: e.toString()));
   ```

---

## Чек-листы использования

### Когда использовать Cubit
- ✓ Простая логика (счётчики, переключатели)
- ✓ Локальное состояние экрана
- ✓ Прототипирование
- ✓ Обучение flutter_bloc

### Когда использовать Bloc
- ✓ Сложная бизнес-логика
- ✓ Необходима детальная история событий
- ✓ Множество различных действий над одним состоянием
- ✓ Команда предпочитает явные события

### Когда НЕ использовать flutter_bloc
- ✗ Простое локальное состояние (используйте StatefulWidget)
- ✗ Анимации (используйте AnimationController)
- ✗ Состояние формы (можно использовать обычные TextEditingController)
- ✗ Временное UI состояние (открыт ли дропдаун и т.п.)

---

## Вопросы для самопроверки

### Вопрос 1: В чём основное отличие Cubit от Bloc?

**Ответ:**
Основное отличие в способе изменения состояния:
- **Cubit** использует прямые методы: `cubit.increment()`, `cubit.decrement()` - проще и лаконичнее
- **Bloc** использует события: `bloc.add(IncrementEvent())` - более структурировано и подходит для сложной логики

Cubit подходит для простых случаев, Bloc - для сложной бизнес-логики с множеством событий.

### Вопрос 2: Когда использовать BlocListener вместо BlocBuilder?

**Ответ:**
**BlocListener** используется для **побочных эффектов** (side effects), которые не связаны с построением UI:
- Навигация на другой экран
- Показ SnackBar, Toast, Dialog
- Вызов других сервисов

**BlocBuilder** используется для **перестройки UI** на основе состояния.

Пример: при успешном логине нужно перейти на главный экран (BlocListener) И показать индикатор загрузки (BlocBuilder).

### Вопрос 3: Что произойдёт, если не использовать copyWith() или Equatable?

**Ответ:**
Без `copyWith()` или `Equatable` могут возникнуть проблемы:

1. **Без copyWith()**: Если мутировать существующий объект состояния напрямую, BLoC не обнаружит изменений, так как ссылка на объект осталась той же. UI не обновится.

2. **Без Equatable**: BlocBuilder будет перестраиваться при каждом `emit()`, даже если данные не изменились, потому что dart сравнивает объекты по ссылке, а не по содержимому.

```dart
// Плохо (без copyWith):
state.count++;  // мутация - НЕ РАБОТАЕТ
emit(state);

// Хорошо:
emit(state.copyWith(count: state.count + 1));

// Плохо (без Equatable):
class MyState {  // будет перестраиваться всегда
  final int count;
  MyState(this.count);
}

// Хорошо:
class MyState extends Equatable {  // сравнение по значению
  final int count;
  MyState(this.count);

  @override
  List<Object?> get props => [count];
}
```

---

## Итоговые рекомендации

1. **Начните с Cubit** для изучения паттерна, затем переходите к Bloc при необходимости
2. **Используйте Equatable** для состояний - это избавит от лишних перестроек
3. **Разделяйте UI и логику** - никогда не пишите бизнес-логику в виджетах
4. **Применяйте buildWhen/listenWhen** для оптимизации производительности
5. **Тестируйте BLoC/Cubit** независимо от UI - это главное преимущество паттерна
6. **Не переусложняйте** - не все состояния требуют BLoC

---

*Конспект создан в рамках домашнего задания 27*
*Тема: Популярные пакеты - flutter_bloc (BLoC/Cubit)*
